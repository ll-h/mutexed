<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="dark-mode" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mutexed: llh::mutexed::Mutexed&lt; T, M, H &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mutexed<span id="projectnumber">&#160;0.0.1</span>
   </div>
   <div id="projectbrief">A header-only mutex-protected value wrapper for C++20.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>llh</b></li><li class="navelem"><b>mutexed</b></li><li class="navelem"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">Mutexed</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classllh_1_1mutexed_1_1Mutexed-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llh::mutexed::Mutexed&lt; T, M, H &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html" title="The Mutexed class is a value-wrapper that protects its value with a mutex that will be referred to in...">Mutexed</a> class is a value-wrapper that protects its value with a mutex that will be referred to in this documentation as the <em>inner mutex</em>.  
 <a href="classllh_1_1mutexed_1_1Mutexed.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for llh::mutexed::Mutexed&lt; T, M, H &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classllh_1_1mutexed_1_1Mutexed__inherit__graph.svg" width="440" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for llh::mutexed::Mutexed&lt; T, M, H &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classllh_1_1mutexed_1_1Mutexed__coll__graph.svg" width="440" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a455c61d7109ff4736d632c2b2968a72e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a455c61d7109ff4736d632c2b2968a72e">value_type</a> = T</td></tr>
<tr class="memdesc:a455c61d7109ff4736d632c2b2968a72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the wrapped value.  <br /></td></tr>
<tr class="separator:a455c61d7109ff4736d632c2b2968a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78ac2e4959ef1b18e68ab62e5983926"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aa78ac2e4959ef1b18e68ab62e5983926">mutex_type</a> = M</td></tr>
<tr class="memdesc:aa78ac2e4959ef1b18e68ab62e5983926"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <em>inner mutex</em>  <br /></td></tr>
<tr class="separator:aa78ac2e4959ef1b18e68ab62e5983926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2f349cd0d26d3b8b002e9bf236d556"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a> = std::conditional_t&lt; shared_lockable&lt; M &gt;, std::shared_lock&lt; M &gt;, std::unique_lock&lt; M &gt; &gt;</td></tr>
<tr class="memdesc:a1b2f349cd0d26d3b8b002e9bf236d556"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::shared_lock&lt;M&gt;</code> if <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aa78ac2e4959ef1b18e68ab62e5983926" title="The type of the inner mutex">Mutexed::mutex_type</a> is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a>, a <code>std::unique_lock&lt;M&gt;</code> otherwise.  <br /></td></tr>
<tr class="separator:a1b2f349cd0d26d3b8b002e9bf236d556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a243026a94e472bae2eb418ef8ebaa505"><td class="memItemLeft" align="right" valign="top"><a id="a243026a94e472bae2eb418ef8ebaa505" name="a243026a94e472bae2eb418ef8ebaa505"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mutexed</b> (<a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">Mutexed</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a243026a94e472bae2eb418ef8ebaa505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d5fc50dd198523a229ff749c0bc0f3"><td class="memItemLeft" align="right" valign="top"><a id="a05d5fc50dd198523a229ff749c0bc0f3" name="a05d5fc50dd198523a229ff749c0bc0f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mutexed</b> (<a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">Mutexed</a> const &amp;)=delete</td></tr>
<tr class="separator:a05d5fc50dd198523a229ff749c0bc0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e910f2332c4e6bbf324cf85210889bf"><td class="memTemplParams" colspan="2">template&lt;typename... ValueArgs&gt; <br />
requires does_not_contain_tag&lt;<a class="el" href="structllh_1_1mutexed_1_1mutex__args__t.html">mutex_args_t</a>, ValueArgs...&gt; &amp;&amp; std::is_constructible_v&lt;T, ValueArgs&amp;&amp;...&gt;</td></tr>
<tr class="memitem:a3e910f2332c4e6bbf324cf85210889bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a3e910f2332c4e6bbf324cf85210889bf">Mutexed</a> (ValueArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3e910f2332c4e6bbf324cf85210889bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place-constructs the wrapped value with the provided arguments and default-initializes the mutex.  <br /></td></tr>
<tr class="separator:a3e910f2332c4e6bbf324cf85210889bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b8620321b0df1135c5f9195c445f0f"><td class="memTemplParams" colspan="2">template&lt;typename ValArg , typename MutexArg &gt; </td></tr>
<tr class="memitem:a94b8620321b0df1135c5f9195c445f0f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a94b8620321b0df1135c5f9195c445f0f">Mutexed</a> (ValArg &amp;&amp;v_arg, MutexArg &amp;&amp;m_arg)</td></tr>
<tr class="memdesc:a94b8620321b0df1135c5f9195c445f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the first argument to the constructor of the value and the second argument to the constructor of the mutex.  <br /></td></tr>
<tr class="separator:a94b8620321b0df1135c5f9195c445f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b31586941f5d9521ddb13d2b5dd7d0"><td class="memTemplParams" colspan="2">template&lt;typename... MutexArgs&gt; <br />
requires does_not_contain_tag&lt;<a class="el" href="structllh_1_1mutexed_1_1value__args__t.html">value_args_t</a>, MutexArgs...&gt;</td></tr>
<tr class="memitem:aa4b31586941f5d9521ddb13d2b5dd7d0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aa4b31586941f5d9521ddb13d2b5dd7d0">Mutexed</a> (<a class="el" href="structllh_1_1mutexed_1_1mutex__args__t.html">mutex_args_t</a>, MutexArgs &amp;&amp;... m_args)</td></tr>
<tr class="memdesc:aa4b31586941f5d9521ddb13d2b5dd7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place-constructs the mutex with the provided arguments and default-initializes the wrapped value.  <br /></td></tr>
<tr class="separator:aa4b31586941f5d9521ddb13d2b5dd7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79647e1e37561ce7476bb97b4897563"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires invokable_with&lt;F, T const&amp;&gt; || invokable_with&lt;F, T&gt; &amp;&amp; std::is_copy_constructible_v&lt;T&gt;</td></tr>
<tr class="memitem:ac79647e1e37561ce7476bb97b4897563"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#ac79647e1e37561ce7476bb97b4897563">with_locked</a> (F &amp;&amp;f) const</td></tr>
<tr class="memdesc:ac79647e1e37561ce7476bb97b4897563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <em>f</em> with a <code>const&amp;</code> or a copy of the wrapped value while locking the <em>inner mutex</em>.  <br /></td></tr>
<tr class="separator:ac79647e1e37561ce7476bb97b4897563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79dcbca0dcbe65404b95c77edfdba2c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires invokable_with&lt;F, T&amp;&gt;</td></tr>
<tr class="memitem:ac79dcbca0dcbe65404b95c77edfdba2c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#ac79dcbca0dcbe65404b95c77edfdba2c">with_locked</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ac79dcbca0dcbe65404b95c77edfdba2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <em>f</em> with a reference on the wrapped value while locking the <em>inner mutex</em>.  <br /></td></tr>
<tr class="separator:ac79dcbca0dcbe65404b95c77edfdba2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea76bd0c368e838877fe8d72ad804a9"><td class="memTemplParams" colspan="2">template&lt;typename  = void&gt; <br />
requires std::is_copy_constructible_v&lt;T&gt;</td></tr>
<tr class="memitem:a5ea76bd0c368e838877fe8d72ad804a9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a5ea76bd0c368e838877fe8d72ad804a9">get_copy</a> () const</td></tr>
<tr class="memdesc:a5ea76bd0c368e838877fe8d72ad804a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the wrapped value while locking the inner mutex.  <br /></td></tr>
<tr class="separator:a5ea76bd0c368e838877fe8d72ad804a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700d33e8c621e4f0096108799ad78422"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; <br />
requires std::is_same_v&lt;H, <a class="el" href="structllh_1_1mutexed_1_1has__cv.html">has_cv</a>&gt; &amp;&amp; invokable_with&lt;Predicate, T const&amp;&gt;</td></tr>
<tr class="memitem:ga700d33e8c621e4f0096108799ad78422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Waiting.html#ga700d33e8c621e4f0096108799ad78422">wait</a> (Predicate &amp;&amp;p) const</td></tr>
<tr class="memdesc:ga700d33e8c621e4f0096108799ad78422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until <code>this</code> is notified and the provided predicate returns <code>true</code>.  <br /></td></tr>
<tr class="separator:ga700d33e8c621e4f0096108799ad78422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6259ea8c9919f988f094e653e38d55ea"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename Predicate &gt; <br />
requires std::is_same_v&lt;H, <a class="el" href="structllh_1_1mutexed_1_1has__cv.html">has_cv</a>&gt; &amp;&amp; invokable_with&lt;Predicate, T const&amp;&gt;</td></tr>
<tr class="memitem:ga6259ea8c9919f988f094e653e38d55ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Waiting.html#ga6259ea8c9919f988f094e653e38d55ea">wait_for</a> (std::chrono::duration&lt; Rep, Period &gt; const &amp;rel_time, Predicate &amp;&amp;p) const</td></tr>
<tr class="memdesc:ga6259ea8c9919f988f094e653e38d55ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until <code>this</code> is notified and the provided predicate returns <code>true</code> or until the specified duration has been spent waiting.  <br /></td></tr>
<tr class="separator:ga6259ea8c9919f988f094e653e38d55ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec329cf40472f9670a20fcffec39e03"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration , typename Predicate &gt; <br />
requires std::is_same_v&lt;H, <a class="el" href="structllh_1_1mutexed_1_1has__cv.html">has_cv</a>&gt; &amp;&amp; invokable_with&lt;Predicate, T const&amp;&gt;</td></tr>
<tr class="memitem:ga3ec329cf40472f9670a20fcffec39e03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Waiting.html#ga3ec329cf40472f9670a20fcffec39e03">wait_until</a> (std::chrono::time_point&lt; Clock, Duration &gt; const &amp;timeout_time, Predicate &amp;&amp;p) const</td></tr>
<tr class="memdesc:ga3ec329cf40472f9670a20fcffec39e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until <code>this</code> is notified and the provided predicate returns <code>true</code> or until the specified time point has been passed.  <br /></td></tr>
<tr class="separator:ga3ec329cf40472f9670a20fcffec39e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee894d369c7c0b3cf55826e01e68363"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aeee894d369c7c0b3cf55826e01e68363">locked</a> ()</td></tr>
<tr class="memdesc:aeee894d369c7c0b3cf55826e01e68363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the <em>wrapped value</em> through a tuple of an unspecified lock guard and a reference to the value.  <br /></td></tr>
<tr class="separator:aeee894d369c7c0b3cf55826e01e68363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1be3d9f54974968071e84f71c482a6"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a>, T const &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aed1be3d9f54974968071e84f71c482a6">locked</a> () const</td></tr>
<tr class="memdesc:aed1be3d9f54974968071e84f71c482a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#ac4bdb4af394dca3070870697e0dfa3ba" title="Provides const access to the wrapped value through a tuple of a possibly_shared_lock and a const refe...">locked_const()</a>.  <br /></td></tr>
<tr class="separator:aed1be3d9f54974968071e84f71c482a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bdb4af394dca3070870697e0dfa3ba"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a>, T const &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#ac4bdb4af394dca3070870697e0dfa3ba">locked_const</a> () const</td></tr>
<tr class="memdesc:ac4bdb4af394dca3070870697e0dfa3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <code>const</code> access to the <em>wrapped value</em> through a tuple of a <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a> and a <code>const</code> reference to the <em> wrapped value</em>.  <br /></td></tr>
<tr class="separator:ac4bdb4af394dca3070870697e0dfa3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename M = std::shared_mutex, typename H = no_cv&gt;<br />
class llh::mutexed::Mutexed&lt; T, M, H &gt;</div><p>The <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html" title="The Mutexed class is a value-wrapper that protects its value with a mutex that will be referred to in...">Mutexed</a> class is a value-wrapper that protects its value with a mutex that will be referred to in this documentation as the <em>inner mutex</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the <em>wrapped value</em>. </td></tr>
    <tr><td class="paramname">M</td><td>the type of the <em>inner mutex</em>. If it is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a> , <em>read-access</em> to the <em>wrapped value</em> is done by using the <code>lock_shared()</code> function of the <em>inner mutex</em>. </td></tr>
    <tr><td class="paramname">H</td><td>option to activate <a class="el" href="group__Waiting.html">The waiting feature</a> if it is <a class="el" href="structllh_1_1mutexed_1_1has__cv.html" title="A tag type to use as last template argument of Mutexed to enable the waiting API but making it handle...">has_cv</a>. The default value is <a class="el" href="structllh_1_1mutexed_1_1no__cv.html" title="The default last template argument of Mutexed, disabling the waiting API but not pay its costs.">no_cv</a>, in which case no <em>condition-variable</em> is held and waiting functions are not available. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00162">162</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa78ac2e4959ef1b18e68ab62e5983926" name="aa78ac2e4959ef1b18e68ab62e5983926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78ac2e4959ef1b18e68ab62e5983926">&#9670;&#160;</a></span>mutex_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::mutex_type =  M</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the <em>inner mutex</em> </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00197">197</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="a1b2f349cd0d26d3b8b002e9bf236d556" name="a1b2f349cd0d26d3b8b002e9bf236d556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2f349cd0d26d3b8b002e9bf236d556">&#9670;&#160;</a></span>possibly_shared_lock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::possibly_shared_lock =  std::conditional_t&lt; shared_lockable&lt;M&gt;, std::shared_lock&lt;M&gt;, std::unique_lock&lt;M&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>std::shared_lock&lt;M&gt;</code> if <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#aa78ac2e4959ef1b18e68ab62e5983926" title="The type of the inner mutex">Mutexed::mutex_type</a> is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a>, a <code>std::unique_lock&lt;M&gt;</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00202">202</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="a455c61d7109ff4736d632c2b2968a72e" name="a455c61d7109ff4736d632c2b2968a72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455c61d7109ff4736d632c2b2968a72e">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the wrapped value. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00195">195</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e910f2332c4e6bbf324cf85210889bf" name="a3e910f2332c4e6bbf324cf85210889bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e910f2332c4e6bbf324cf85210889bf">&#9670;&#160;</a></span>Mutexed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename... ValueArgs&gt; <br />
requires does_not_contain_tag&lt;<a class="el" href="structllh_1_1mutexed_1_1mutex__args__t.html">mutex_args_t</a>, ValueArgs...&gt; &amp;&amp; std::is_constructible_v&lt;T, ValueArgs&amp;&amp;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::Mutexed </td>
          <td>(</td>
          <td class="paramtype">ValueArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place-constructs the wrapped value with the provided arguments and default-initializes the mutex. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00216">216</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="a94b8620321b0df1135c5f9195c445f0f" name="a94b8620321b0df1135c5f9195c445f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b8620321b0df1135c5f9195c445f0f">&#9670;&#160;</a></span>Mutexed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename ValArg , typename MutexArg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::Mutexed </td>
          <td>(</td>
          <td class="paramtype">ValArg &amp;&amp;&#160;</td>
          <td class="paramname"><em>v_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MutexArg &amp;&amp;&#160;</td>
          <td class="paramname"><em>m_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards the first argument to the constructor of the value and the second argument to the constructor of the mutex. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00221">221</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="aa4b31586941f5d9521ddb13d2b5dd7d0" name="aa4b31586941f5d9521ddb13d2b5dd7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b31586941f5d9521ddb13d2b5dd7d0">&#9670;&#160;</a></span>Mutexed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename... MutexArgs&gt; <br />
requires does_not_contain_tag&lt;<a class="el" href="structllh_1_1mutexed_1_1value__args__t.html">value_args_t</a>, MutexArgs...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::Mutexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllh_1_1mutexed_1_1mutex__args__t.html">mutex_args_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MutexArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>m_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place-constructs the mutex with the provided arguments and default-initializes the wrapped value. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00230">230</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ea76bd0c368e838877fe8d72ad804a9" name="a5ea76bd0c368e838877fe8d72ad804a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea76bd0c368e838877fe8d72ad804a9">&#9670;&#160;</a></span>get_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename  = void&gt; <br />
requires std::is_copy_constructible_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::get_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a copy of the wrapped value while locking the inner mutex. </p>
<p>If <em>M</em> is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a>, <code>lock_shared()</code> will be used. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00307">307</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="aeee894d369c7c0b3cf55826e01e68363" name="aeee894d369c7c0b3cf55826e01e68363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee894d369c7c0b3cf55826e01e68363">&#9670;&#160;</a></span>locked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the <em>wrapped value</em> through a tuple of an unspecified lock guard and a reference to the value. </p>
<p>Use it this way : </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> [lock, ref] = <span class="keyword">protected</span>.locked();</div>
<div class="line">    ref += 42;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function <em>unique-locks</em> the <em>inner mutex</em> before returning the tuple. The lock-guard returned has a destructor that unlocks the <em>inner mutex</em> and then, if <a class="el" href="group__Waiting.html">The waiting feature</a> is enabled, notifies the <em>inner condition-variable</em>. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00415">415</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="aed1be3d9f54974968071e84f71c482a6" name="aed1be3d9f54974968071e84f71c482a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1be3d9f54974968071e84f71c482a6">&#9670;&#160;</a></span>locked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a>, T const  &amp; &gt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#ac4bdb4af394dca3070870697e0dfa3ba" title="Provides const access to the wrapped value through a tuple of a possibly_shared_lock and a const refe...">locked_const()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00441">441</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="ac4bdb4af394dca3070870697e0dfa3ba" name="ac4bdb4af394dca3070870697e0dfa3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bdb4af394dca3070870697e0dfa3ba">&#9670;&#160;</a></span>locked_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a>, T const  &amp; &gt; <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::locked_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <code>const</code> access to the <em>wrapped value</em> through a tuple of a <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a1b2f349cd0d26d3b8b002e9bf236d556">possibly_shared_lock</a> and a <code>const</code> reference to the <em> wrapped value</em>. </p>
<p>Use it this way : </p><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> [lock, ref] = <span class="keyword">protected</span>.locked_const();</div>
<div class="line">    std::cout &lt;&lt; ref;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function locks the <em>inner mutex</em> before returning the tuple. The locking is shared if that mutex is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a>, and regular (<code>lock()</code> used) otherwise.</p>
<p>The lock guard returned has a destructor that unlocks the <em>inner mutex</em>. </p>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00463">463</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="ac79dcbca0dcbe65404b95c77edfdba2c" name="ac79dcbca0dcbe65404b95c77edfdba2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79dcbca0dcbe65404b95c77edfdba2c">&#9670;&#160;</a></span>with_locked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; <br />
requires invokable_with&lt;F, T&amp;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::with_locked </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <em>f</em> with a reference on the wrapped value while locking the <em>inner mutex</em>. </p>
<p>If <a class="el" href="group__Waiting.html">The waiting feature</a> is enabled, the <em>inner</em> condition-variable is notified with <code>notify_all()</code> after the <em>inner mutex</em> is unlocked.</p>
<p>This overload is chosen if <code>this</code> is not <code>const</code> and if <code>f</code> is <a class="el" href="conceptllh_1_1mutexed_1_1invokable__with.html">invokable_with </a> a non-<code>const</code> reference to <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a455c61d7109ff4736d632c2b2968a72e">value_type</a>.</p>
<p>Example usage : </p><div class="fragment"><div class="line"><a class="code hl_class" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed&lt;int&gt;</a> protected_int(0);</div>
<div class="line">protected_int.with_locked([](<span class="keywordtype">int</span>&amp; val){ val += 42; });</div>
<div class="ttc" id="aclassllh_1_1mutexed_1_1Mutexed_html"><div class="ttname"><a href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a></div><div class="ttdoc">The Mutexed class is a value-wrapper that protects its value with a mutex that will be referred to in...</div><div class="ttdef"><b>Definition</b> <a href="mutexed_8hpp_source.html#l00162">mutexed.hpp:162</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor that will be called with a reference to the wrapped value while the <em>inner mutex</em> will be locked. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00297">297</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<a id="ac79647e1e37561ce7476bb97b4897563" name="ac79647e1e37561ce7476bb97b4897563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79647e1e37561ce7476bb97b4897563">&#9670;&#160;</a></span>with_locked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename M  = std::shared_mutex, typename H  = no_cv&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; <br />
requires invokable_with&lt;F, T const&amp;&gt; || invokable_with&lt;F, T&gt; &amp;&amp; std::is_copy_constructible_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed</a>&lt; T, M, H &gt;::with_locked </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <em>f</em> with a <code>const&amp;</code> or a copy of the wrapped value while locking the <em>inner mutex</em>. </p>
<p>If the <em>inner mutex</em> is <a class="el" href="conceptllh_1_1mutexed_1_1shared__lockable.html">shared_lockable </a>, <code>lock_shared()</code> will be used.</p>
<p>This overload is chosen if <code>this</code> is <code>const</code> or if <code>f</code> is <a class="el" href="conceptllh_1_1mutexed_1_1invokable__with.html">invokable_with </a> either <a class="el" href="classllh_1_1mutexed_1_1Mutexed.html#a455c61d7109ff4736d632c2b2968a72e">value_type</a> or a <code>const&amp;</code> to it.</p>
<p>Example usage : </p><div class="fragment"><div class="line"><span class="keyword">struct </span>read_me {</div>
<div class="line">    <span class="keywordtype">int</span> val = 42;</div>
<div class="line">    <span class="keywordtype">int</span> value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> val; }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_class" href="classllh_1_1mutexed_1_1Mutexed.html">llh::mutexed::Mutexed&lt;read_me&gt;</a> protected_int;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// with a const member function :</span></div>
<div class="line">std::cout &lt;&lt; protected_int.<a class="code hl_function" href="classllh_1_1mutexed_1_1Mutexed.html#ac79647e1e37561ce7476bb97b4897563">with_locked</a>(&amp;read_me::value) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// with a lambda taking a const ref :</span></div>
<div class="line">std::cout &lt;&lt; protected_int.<a class="code hl_function" href="classllh_1_1mutexed_1_1Mutexed.html#ac79647e1e37561ce7476bb97b4897563">with_locked</a>([](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; rm){ <span class="keywordflow">return</span> rm.val; }) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// with a lambda taking an auto but from a const Mutexed :</span></div>
<div class="line">std::cout &lt;&lt; std::cref(protected_int).get().with_locked([](<span class="keyword">auto</span> rm){ <span class="keywordflow">return</span> rm.val; }) &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassllh_1_1mutexed_1_1Mutexed_html_ac79647e1e37561ce7476bb97b4897563"><div class="ttname"><a href="classllh_1_1mutexed_1_1Mutexed.html#ac79647e1e37561ce7476bb97b4897563">llh::mutexed::Mutexed::with_locked</a></div><div class="ttdeci">decltype(auto) with_locked(F &amp;&amp;f) const</div><div class="ttdoc">Calls f with a const&amp; or a copy of the wrapped value while locking the inner mutex.</div><div class="ttdef"><b>Definition</b> <a href="mutexed_8hpp_source.html#l00270">mutexed.hpp:270</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor that will be called with the wrapped value while the <em>inner mutex</em> will be locked. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mutexed_8hpp_source.html#l00270">270</a> of file <a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/llh/<a class="el" href="mutexed_8hpp_source.html">mutexed.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
